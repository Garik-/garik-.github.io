<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="/stylesheets/style.css"><link rel="icon" href="/images/favicon.ico"><link rel="apple-touch-icon" href="/images/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><script src="/javascripts/counter.js"></script><title>Получаем доступ к истории переписки и контактам в популярном мессенджере | by Igor Riakhovskii</title><meta name="description" content="Ты вряд ли пользуешься Mail.Ru Агентом, но это бешено популярный сервис, который с каждым днем набирает обороты. По официальным данным месячная..."><meta property="og:title" content="Получаем доступ к истории переписки и контактам в популярном мессенджере"><meta property="og:description" content="Ты вряд ли пользуешься Mail.Ru Агентом, но это бешено популярный сервис, который с каждым днем набирает обороты. По официальным данным месячная..."><meta property="og:type" content="article"><meta property="article:published_time" content="2012-11-30T15:00:00+04:00"><meta property="article:modified_time" content="2012-11-30T15:00:00+04:00"><meta property="profile:first_name" content="Igor"><meta property="profile:last_name" content="Riakhovskii"><meta property="profile:username" content="garikdjan"></head><body><main class="article-layout"><div class="container"><article><h1 class="post-title">Получаем доступ к истории переписки и контактам в популярном мессенджере</h1><section class="post-info"><a class="author-photo-link" rel="noopener follow" href="/"><img class="author-photo" alt="Igor Riakhovskii" src="/v1/resize:fill:88:88/public/avatar.jpg" width="44" height="44" loading="lazy"><div class="author-photo-shadow"></div></a><div class="post-info-author"><a class="author-name" rel="noopener follow" href="/">Igor Riakhovskii</a><div class="post-info-date"><span>10 min read</span><span class="separator">·</span><span>Nov 30, 2012</span></div></div></section><div class="post-content"><p>Ты вряд ли пользуешься Mail.Ru Агентом, но это бешено популярный сервис, который с каждым днем набирает обороты. По официальным данным месячная аудитория этого мессенджера в конце прошлого года составляла безумную цифру в 21,4 миллиона человек. Это легко объяснить, — продукт действительно удачный. Но сегодня я хочу рассказать о том, как был разреверсен файл с историей сообщений пользователя.</p>
<p><mark>Не забывай о статье 138 — «Нарушение тайны переписки, телефонных переговоров, почтовых, телеграфных или иных сообщений» УК РФ, а также о наличии в ней главы 28 — «Преступления в сфере компьютерной информации» (ст. 272, 273, 274).</mark></p>
<h1>История взлома</h1>
<p>Эксперимент начался для меня еще в далеком 2008 году, когда друг попросил проверить переписку его девушки в Mail.ru Агенте. Тогда файл истории представлял из себя простой текстовик с названием <code>email_history.txt</code> и имел по сравнению с <code>mra.dbs</code> (файл, в котором в настоящее время хранится история переписки и данные о контактах) примитивную структуру. За пару часов был написан простой, но эффективный RTF-конвертер, который и делал всю грязную работу по вытягиванию переписки из Агента. Друг был в восторге. Далее, в ходе изучения программирования на компилируемых языках, я в качестве практики написал программу Mail.ru History Reader, описание которой попало на страницы ][ в августе 2009 года. Получив большое количество положительных отзывов, я опубликовал структуру формата тогдашнего файла истории (см. ссылки в боковом выносе) и исходники читалки. Однако Mail.ru Агент продолжал развиваться, и править балом стал новый продвинутый файл mra.dbs. После этого события ко мне посыпались тонны сообщений от различных людей с просьбами заняться им. В компании с SOLON7 мы ковыряли этот файл в HEX-редакторе, пытаясь найти структуры, ссылки на смещения и всевозможные изменения после запуска Mail.ru Агента. К концу 2010 года после долгих поисков формат все-таки покорился.</p>

  <figure>
    <picture>
        <source srcset="/v1/resize:fit:640/format:webp/20250112185240.png 640w, /v1/resize:fit:720/format:webp/20250112185240.png 720w, /v1/resize:fit:750/format:webp/20250112185240.png 750w, /v1/resize:fit:768/format:webp/20250112185240.png 768w, /v1/resize:fit:828/format:webp/20250112185240.png 828w, /v1/resize:fit:1100/format:webp/20250112185240.png 1100w, /v1/resize:fit:1400/format:webp/20250112185240.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp">
        <source srcset="/v1/resize:fit:640/20250112185240.png 640w, /v1/resize:fit:720/20250112185240.png 720w, /v1/resize:fit:750/20250112185240.png 750w, /v1/resize:fit:768/20250112185240.png 768w, /v1/resize:fit:828/20250112185240.png 828w, /v1/resize:fit:1100/20250112185240.png 1100w, /v1/resize:fit:1400/20250112185240.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px">
        <img alt="" width="819" height="393" loading="lazy" role="presentation" src="/v1/resize:fit:1400/20250112185240.png">
    </picture>
    <figcaption>Идентификаторы начала переписки</figcaption>
  </figure>
  
<blockquote>
<h2>Rich Text Format (RTF)</h2>
<p>RTF, использующийся в <code>mra.dbs</code>, представляет из себя формат хранения размеченных документов, предложенный еще в 1982 году бородатыми программистами из Microsoft и Adobe. Для его парсинга совершенно не обязательно изобретать велосипед, а достаточно лишь отправить сообщение <code>EM_STREAMIN</code> с флагом <code>SF_RTF</code> для записи и <code>EM_STREAMOUT</code> с флагом <code>SF_TEXT</code> для чтения:</p>
<pre><code class="hljs language-cpp">EDITSTREAM es = { <span class="hljs-number">0</span> };
es.pfnCallback = EditStreamCallback;
es.dwCookie = (DWORD_PTR)&#x26;lps;
<span class="hljs-built_in">SendMessage</span>(hRich, EM_STREAMIN, SF_RTF, (LPARAM)&#x26;es); 
</code></pre>
<p>Этот нехитрый прием и использован в моей читалке.</p>
</blockquote>
<h1>Как добыть файл mra.dbs?</h1>
<p>Ты, конечно, задашься вопросом: а где, собственно, хранится этот пресловутый <code>mra.dbs</code>, и как его добыть? Файл <code>mra.dbs</code> хранится в папке «<code>%APPDATA%\Mra\Base\mra.dbs</code>» (например «<code>C:\Documents and Settings\user\Application Data\Mra\Base\mra.dbs</code>»), и заполучить его при выключенном Агенте не так уж и сложно, достаточно лишь использовать функции <code>ExpandEnvironmentStrings</code> и <code>CopyFile</code>. Однако при включенном Агенте файл <code>mra.dbs</code> является занятым и система попросту не позволит его использовать. Для решения этой проблемы можно, например, временно отключить Агент (для этого действия тебе понадобятся привилегии отладчика, которые можно получить только с правами Администратора) или найти открытый хэндл файла в системе, а затем продублировать его в адресное пространство своего процесса. Также можно прочесть файл напрямую с диска (правда, для этого нужно знать, что такое кластер и как работать напрямую с драйвером файловой системы) или же написать собственный файловый драйвер (это практически нереально). Все бы хорошо, но на практике у всех вышеперечисленных методов есть свои недостатки. При перечислении хэндлов с помощью <code>ZwQuerySystemInformation</code> и их копировании к себе в процесс с помощью <code>DuplicateHandle</code> можно столкнуться с двумя проблемами. Первая заключается в том, что при вызове <code>ZwQueryInformationFile</code> поток может повиснуть, ожидая отклика от блокирующего именованного канала. Вторая — после копирования оба хэндла (наш и открывшего файл процесса) будут указывать на один FileObject, а следовательно — текущий режим ввода-вывода. Позиция в файле и другая связанная с файлом информация будут общими у двух процессов, поэтому даже чтение файла вызовет изменение позиции чтения и нарушение нормальной работы программы, открывшей файл. Конечно, можно приостановить на время все потоки процесса файла, а после копирования восстанавливать позиции чтения и запускать процесс владельца снова, но это связано с большими затратами времени и сил. Казалось бы, идеальным методом может являться прямое чтение с диска, но и здесь есть недостатки. Таким способом можно читать только файлы, которые открываются с доступом <code>FILE_READ_ATTRIBUTES</code> (кроме файлов подкачки), файл обязательно должен быть не сжат, не зашифрован (иначе мы прочитаем ерунду) и иметь свой кластер (маленькие файлы в NTFS могут целиком размещаться в MFT). Также следует учесть, что во время чтения файл может быть изменен (и мы получим в результате непонятно что). Поэтому разберем самый простой метод с временным отключением процесса Агента.</p>
<p>Итак, чтобы убить процесс Mail.ru Агента, для начала необходимо узнать его идентификатор (ProcessID). Сделать это можно разными способами: через ToolHelp API, через Native API (используя функцию <code>ZwQuerySystemInformation</code>), прошерстив список открытых хэндлов или по списку открытых процессом окон (<code>GetWindowThreadProcessId</code>). Самый легкий вариант — это использование ToolHelp API и поиск по имени exe-файла. Для этого достаточно вызвать функции <code>CreateToolhelp32Snapshot > Process32First > Process32Next</code>, а затем в теле цикла сверять значение поля <code>szExeFile</code> структуры <code>PROCESSENTRY32</code> c magent.exe. Необходимый нам ProcessID находится в этой же структуре, поле <code>th32ProcessID</code>:</p>
<pre><code class="hljs language-cpp">hProcessSnap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span> (INVALID_HANDLE_VALUE != hProcessSnap) {
  pe<span class="hljs-number">32.</span>dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(hProcessSnap, &#x26;pe32)) {
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">lstrcmp</span>(pe<span class="hljs-number">32.</span>szExeFile, _TEXT(<span class="hljs-string">"magent.exe"</span>))) {
        pid = pe<span class="hljs-number">32.</span>th32ProcessID;
        <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(hProcessSnap, &#x26;pe32));
  }
  <span class="hljs-built_in">CloseHandle</span>(hProcessSnap);
}
</code></pre>
<p>После того как мы найдем PID, нам необходимо получить привилегии отладчика SeDebugPrivilege (OpenProcessToken > LookupPrivilegeValue > AdjustTokenPrivileges) и убить процесс (OpenProcess > TerminateProcess), а потом снова попытаться вызвать <code>CopyFile</code>. Привилегии можно получить и более элегантным путем — через Native API:</p>
<pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetPrivilege</span><span class="hljs-params">(IN ULONG Privilege)</span> </span>{
  BOOLEAN OldValue;
  <span class="hljs-built_in">RtlAdjustPrivilege</span>(Privilege, TRUE, FALSE, &#x26;OldValue);
}
</code></pre>
<p>Все, <code>mra.dbs</code> у нас в руках. Теперь перейдем к его потрошению :).</p>
<h1>Раскрываем секреты mra.dbs</h1>
<p>Файл <code>mra.dbs</code> представляет из себя дамп памяти Mail.ru Агента, поэтому открыть его для чтения при работающей программе не представляется возможным (для рядового программиста, но у нас свои секреты :), также задачу усложняет тот факт, что в памяти все числа хранятся в перевернутом виде. Однако давай немного углубимся в реверс-инжиниринг.</p>

  <figure>
    <picture>
        <source srcset="/v1/resize:fit:640/format:webp/20250112190112.png 640w, /v1/resize:fit:720/format:webp/20250112190112.png 720w, /v1/resize:fit:750/format:webp/20250112190112.png 750w, /v1/resize:fit:768/format:webp/20250112190112.png 768w, /v1/resize:fit:828/format:webp/20250112190112.png 828w, /v1/resize:fit:1100/format:webp/20250112190112.png 1100w, /v1/resize:fit:1400/format:webp/20250112190112.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp">
        <source srcset="/v1/resize:fit:640/20250112190112.png 640w, /v1/resize:fit:720/20250112190112.png 720w, /v1/resize:fit:750/20250112190112.png 750w, /v1/resize:fit:768/20250112190112.png 768w, /v1/resize:fit:828/20250112190112.png 828w, /v1/resize:fit:1100/20250112190112.png 1100w, /v1/resize:fit:1400/20250112190112.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px">
        <img alt="" width="804" height="80" loading="lazy" role="presentation" src="/v1/resize:fit:1400/20250112190112.png">
    </picture>
    <figcaption>Структура записи сообщения</figcaption>
  </figure>
  
<p>Итак, в недрах mra.dbs существует хеш-таблица, в которой описаны смещения на 4-байтные идентификаторы. Идентификаторы служат для определения начала записи различных структур и сегментов дампа, среди которых и находятся нужные нам записи истории переписки (обрати внимание на соответствующую иллюстрацию):</p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ids</span> {
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id1;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id2;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;
} _ids;
</code></pre>
<blockquote>
<p>Хеш-таблица — это структура данных, реализующая интерфейс ассоциативного массива, она позволяет хранить пары «ключ-значение». Двусвязный список состоит из элементов данных, каждый из которых содержит ссылки как на следующий, так и на предыдущий элементы.</p>
</blockquote>
<p>Начало истории характеризуется ключевым словом <code>mrahistory_</code>, за которым следует e-mail хозяина файла <code>mra.dbs</code> и e-mail контакта, с которым ведется переписка. В случае с историей идентификаторы образуют двусвязный список: первый ведет к первому отправленному сообщению, а второй — к последнему принятому сообщению. Количество сообщений можно узнать, изучив четыре байта после идентификаторов (структура _ids). Пройдя по смещению идентификатора (его можно узнать из хеш-таблицы) мы попадем на запись сообщения (снова все внимание на соответствующий рисунок):</p>

  <figure>
    <picture>
        <source srcset="/v1/resize:fit:640/format:webp/20250112190709.png 640w, /v1/resize:fit:720/format:webp/20250112190709.png 720w, /v1/resize:fit:750/format:webp/20250112190709.png 750w, /v1/resize:fit:768/format:webp/20250112190709.png 768w, /v1/resize:fit:828/format:webp/20250112190709.png 828w, /v1/resize:fit:1100/format:webp/20250112190709.png 1100w, /v1/resize:fit:1400/format:webp/20250112190709.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp">
        <source srcset="/v1/resize:fit:640/20250112190709.png 640w, /v1/resize:fit:720/20250112190709.png 720w, /v1/resize:fit:750/20250112190709.png 750w, /v1/resize:fit:768/20250112190709.png 768w, /v1/resize:fit:828/20250112190709.png 828w, /v1/resize:fit:1100/20250112190709.png 1100w, /v1/resize:fit:1400/20250112190709.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px">
        <img alt="" width="672" height="80" loading="lazy" role="presentation" src="/v1/resize:fit:1400/20250112190709.png">
    </picture>
    <figcaption>Поиск хеш-таблицы</figcaption>
  </figure>
  
<pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_message</span> {
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prev_id;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next_id;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> xz1;
  FILETIME time;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type_mesage;
  <span class="hljs-type">char</span> flag_incoming;
  <span class="hljs-type">char</span> byte[<span class="hljs-number">3</span>];
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count_nick;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magic_num;  <span class="hljs-comment">// 0x38</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count_message;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> xz2;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size_lps_rtf;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> xz3;
};
</code></pre>
<p>Строки в дампе сохраняются в кодировке Unicode (wchar_t) различными способами:</p>
<ul>
<li>с завершающим нулем в конце строки;</li>
<li>в структуре LPS (название структуры взято из описания формата протокола MMP), где первые четыре байта указывают на длину последующей строки;</li>
<li>в формате RTF.</li>
</ul>
<p>Зная количество сообщений, нам не составит труда пробежаться по всей цепочке. Но откуда вообще узнать, где находится эта хеш-таблица, и как найти начало записей истории? Над поисками ответов к этим вопросам мы с SOLON7 провели немало бессонных ночей.</p>
<h3>Типы сообщений mra.dbs</h3>
<ul>
<li>2 — неавторизованные пользователи;</li>
<li>4 — запросы авторизации;</li>
<li>7 — обычные сообщения;</li>
<li>10 — передача файлов;</li>
<li>35 — записи в микроблог;</li>
<li>46 — смена геоположения.</li>
</ul>
<h2>Немного магии</h2>
<p>По смещению 0x10 от начала файла mra.dbs, как оказалось, и хранится адрес заветной хеш-таблицы. Пройдя по смещению первого индекса из хеш-таблицы, мы натыкаемся на структуру начальных данных. Возможно, там находится вообще вся информация, заложенная в mra.dbs. Идем дальше. По смещению 0x20 в этой структуре хранится количество записей истории или, проще говоря, количество переписок. Так как файл дампа постоянно расширяется, то по смещению 0x2C лежит идентификатор последней записанной истории, — это все, что нам нужно знать, чтобы начать искать идентификаторы переписок. В целом же алгоритм такой:</p>
<ul>
<li>проходимся по идентификаторам записей истории с помощью цикла (начиная от последней добавленной записи);</li>
<li>если в этой записи от смещения 0x190 присутствует слово «mrahistory_», то это означает, что по смещению 0x24 лежат идентификаторы цепочки сообщений данной переписки.</li>
</ul>
<p>Чтобы стало немного понятней, взгляни на этот код:</p>
<pre><code class="hljs language-cpp">DWORD *offset_table = (DWORD *)(mra_base + *(DWORD *)(mra_base + <span class="hljs-number">0x10</span>));
DWORD end_id_mail = *(DWORD *)(mra_base + <span class="hljs-number">0x20</span> + offset_table[<span class="hljs-number">1</span>]);
DWORD count_emails = *(DWORD *)(mra_base + <span class="hljs-number">0x2C</span> + offset_table[<span class="hljs-number">1</span>]);
<span class="hljs-comment">//...</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &#x3C; count_emails; i++) {
  _ids *mail_data = (<span class="hljs-keyword">struct</span> _ids *)(mra_base + offset_table[end_id_mail] + <span class="hljs-number">4</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memmem</span>(((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)mail_data + <span class="hljs-number">0x190</span>), mrahistory, ...)) {
    emails[k].id = (_ids *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)mail_data + <span class="hljs-number">0x24</span>);
    <span class="hljs-comment">// ...</span>
  }
  end_id_mail = mail_data->id2;
}
</code></pre>

  <figure>
    <picture>
        <source srcset="/v1/resize:fit:640/format:webp/20250112191149.png 640w, /v1/resize:fit:720/format:webp/20250112191149.png 720w, /v1/resize:fit:750/format:webp/20250112191149.png 750w, /v1/resize:fit:768/format:webp/20250112191149.png 768w, /v1/resize:fit:828/format:webp/20250112191149.png 828w, /v1/resize:fit:1100/format:webp/20250112191149.png 1100w, /v1/resize:fit:1400/format:webp/20250112191149.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp">
        <source srcset="/v1/resize:fit:640/20250112191149.png 640w, /v1/resize:fit:720/20250112191149.png 720w, /v1/resize:fit:750/20250112191149.png 750w, /v1/resize:fit:768/20250112191149.png 768w, /v1/resize:fit:828/20250112191149.png 828w, /v1/resize:fit:1100/20250112191149.png 1100w, /v1/resize:fit:1400/20250112191149.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px">
        <img alt="" width="754" height="464" loading="lazy" role="presentation" src="/v1/resize:fit:1400/20250112191149.png">
    </picture>
    <figcaption>Интерфейс моей читалки</figcaption>
  </figure>
  
<h1>Кодим</h1>
<p>Сейчас я покажу тебе лишь самые основные моменты. Итак, файл mra.dbs является дампом памяти, поэтому мы не будем извращаться и использовать функции для работы с файловыми смещениями, а сразу поместим его в память нашей программы. Для этого заюзаем ресурсы ОС Windows и создадим Memory Mapped файл:</p>
<pre><code class="hljs language-cpp">CreateFile
CreateFileMap
MapViewOfFile
VirtualFree
CloseHandle
CloseHandle    
</code></pre>
<p>Так как нам не нужно сохранять внесенные изменения обратно в файл, то здесь вместо UnmapViewOfFile используется VirtualFree. Первое, что мы сделаем, это найдем все контакты из истории переписки. Хранить найденное добро будем в структуре emails:</p>
<pre><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_emails</span> {
  <span class="hljs-type">wchar_t</span> *email;
  _ids *id;
};
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_emails</span> *emails;
<span class="hljs-comment">// ...</span>
emails=<span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>,count_emails*<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> _emails),..);
<span class="hljs-comment">// ...        </span>
</code></pre>
<p>После прохода по идентификаторам и поиска строки «mrahistory_» наша структура будет заполнена адресами идентификаторов. Заметь, при этом мы не скопировали даже байта и израсходовали всего лишь 16*count_emails байт (например, при 1 000 контактов мы используем всего ~15 килобайт памяти). Теперь, имея на руках идентификаторы начала переписки с конкретным пользователем, мы можем прочитать сообщения:</p>
<pre><code class="hljs language-cpp"><span class="hljs-type">int</span> id_message = emails[k].id->id1;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &#x3C; emails[k].id->count_messages; i++) {
  _message *mes = (_message *)(mra_base + offset_table[id_message]);
  <span class="hljs-type">wchar_t</span> *str = (<span class="hljs-type">wchar_t</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)mes + <span class="hljs-built_in">sizeof</span>(_message));
  <span class="hljs-comment">// ...</span>
  id_message = mes->prev_id;
}
</code></pre>
<p>Дата сообщения хранится в формате FILETIME, для удобства ее можно перевести в удобочитаемый вид с помощью функции FileTimeToSystemTime. Формат RTF отлично воспринимается Rich Edit’ом и любыми другими стандартными редакторами типа WordPad. Но с этим можно и не заморачиваться, так как сообщения хранятся в неотформатированном виде сразу после ника, а их размер указан в структуре message. Это все, что тебе нужно знать, чтобы получить удобоваримый список мессаг из Агента.</p>
<h1>WWW</h1>
<ul>
<li><a href="http://bit.ly/z2ETMY">Описание формата истории</a> Mail.ru Агента до версии 5.4;</li>
<li><a href="http://bit.ly/xZoKvU">обсуждение</a> Mail.ru History Reader;</li>
<li><a href="http://bit.ly/zsTJTb">С++ класс</a> для создания winhex.pos-файлов;</li>
<li><a href="http://bit.ly/zNgQ2S">три метода работы</a> с занятыми файлами;</li>
<li><a href="http://bit.ly/w4upzS">различные способы</a> получения списка процессов;</li>
<li>уменьшение размера Си-программы <a href="http://bit.ly/w7sWNA">на примере Visual Studio</a>.</li>
</ul>
<h1>P.S.</h1>
<p>К сожалению, формат журнала не позволяет привести здесь мои хардкорные изыскания полностью, поэтому поспеши заглянуть на диск. Надеюсь, пример кода читалки (exe’шник которой, кстати, с помощью небольшой оптимизации уместился всего в 2 килобайта безо всяких пакеров) поможет тебе в написании быстрого и крутого C-кода, а также в изучении hex-редакторов и других низкоуровневых вещей. Кстати, незатронутой осталась не менее увлекательная тема чтения истории ICQ-переписки, которая также хранится в файле mra.dbs. Спасибо компании Mail.Ru, во-первых, за разработку Mail.Ru Агента, во-вторых, за заметное развитие любимой аськи, и в-третьих, за интересный квест, о котором я тебе сегодня рассказал.</p>
<div class="separator"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
<p>Эта статья была <a href="https://xakep.ru/2012/11/30/mailru-agent-hack/">опубликована журнале «Хакер»</a></p></div></article></div></main><footer class="article-footer"><div class="container"><div class="content"><div class="space"></div><section class="author-section"><a class="author-section-left" rel="noopener follow" href="/"><div class="avatar-box"><img class="avatar mobile-hide" alt="Igor Riakhovskii" src="/v1/resize:fill:96:96/public/avatar.jpg" width="48" height="48" loading="lazy"><div class="avatar-shadow mobile-hide"></div><img class="avatar-big mobile-only" alt="Igor Riakhovskii" src="/v1/resize:fill:128:128/public/avatar.jpg" width="64" height="64" loading="lazy"><div class="avatar-big-shadow mobile-only"></div></div></a><div><a class="author-name" rel="noopener follow" href="/">Written by Igor Riakhovskii</a><div class="author-summary">In commercial development since 2005. At the moment, I am engaged in product development of cloud systems in the role of Technical Lead</div></div></section></div></div></footer></body></html>